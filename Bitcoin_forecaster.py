# -*- coding: utf-8 -*-
"""Trial 2

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/gist/michaelmarchesi/46cc62f99f9155530b978efaf51ff2dc/trial-2.ipynb
"""

import numpy as np
import pandas as pd
from keras.layers.core import Dense,Activation, Dropout
from keras.layers.recurrent import LSTM
from keras.models import Sequential
from sklearn.preprocessing import MinMaxScaler
import matplotlib.pyplot as plt

# Load data
from google.colab import files
uploaded = files.upload()

# Store data
df = pd.read_csv('Binance_BTCUSDT_1h.csv')
df.head(88)

# Modify data
df.drop(['unix','symbol', 'Volume BTC', 'Volume USDT', 'tradecount'],1, inplace=True)
df.head(9)

prediction_days = 90
df['Prediction'] = df[['open']].shift(-prediction_days)
price_close = df[['close']]
price_open = df[['open']] 
price_high = df[['high']]
price_low = df[['low']]

# Create data set

X = np.array(df.drop(['Prediction'],1))

X = X[:len(df)-prediction_days]
print(X)

# Create dependent data set
y = np.array(df['Prediction'])

y = y[:-prediction_days]
print(y)

def create_datasets(dataset, sl):
  sl += 1
  sd =[]
  for i in range(len(dataset)-sl):
    sd.append(dataset[i: i+sl])
  sd = np.array(sd)

  data_x = sd[:,:-1]
  data_y = sd[:,-1]
  
  return data_x, data_y

scaler = MinMaxScaler(feature_range=(0,1))
currency_close_price_scaled = scaler.fit_transform(price_close)
currency_open_price_scaled = scaler.fit_transform(price_open)
currency_high_price_scaled = scaler.fit_transform(price_high)
currency_low_price_scaled = scaler.fit_transform(price_low)


train_size_close = int(len(currency_close_price_scaled)* 0.5)
train_size_open = int(len(currency_open_price_scaled)* 0.5)
train_size_high = int(len(currency_high_price_scaled)* 0.5)
train_size_low = int(len(currency_low_price_scaled)* 0.5)




test_size_close = len(currency_close_price_scaled)-train_size_close
test_size_open = len(currency_open_price_scaled)-train_size_open
test_size_high = len(currency_high_price_scaled)-train_size_high
test_size_low = len(currency_low_price_scaled)-train_size_low



train_close, test_close = currency_close_price_scaled[0:test_size_close,:], currency_close_price_scaled[test_size_close:len(currency_close_price_scaled)]
train_open, test_open = currency_open_price_scaled[0:test_size_open,:], currency_close_price_scaled[test_size_open:len(currency_close_price_scaled)]
train_high, test_high = currency_high_price_scaled[0:test_size_high,:], currency_close_price_scaled[test_size_high:len(currency_close_price_scaled)]
train_low, test_low = currency_low_price_scaled[0:test_size_low,:], currency_close_price_scaled[test_size_low:len(currency_close_price_scaled)]

look_back = 20





x_train_close, y_train_close = create_datasets(train_close, look_back)
x_train_open, y_train_open = create_datasets(train_open, look_back)
x_train_high, y_train_high = create_datasets(train_high, look_back)
x_train_low, y_train_low = create_datasets(train_low, look_back)


x_test_close, y_test_close = create_datasets(test_close,look_back)
x_test_open, y_test_open = create_datasets(test_open,look_back)
x_test_high, y_test_high = create_datasets(test_high,look_back)
x_test_low, y_test_low = create_datasets(test_low,look_back)

#build model

model = Sequential()

model.add(LSTM(100,
    input_shape=(20,1),
    return_sequences=True))
model.add(Dropout(0))

model.add(LSTM(100,
    return_sequences=False))
model.add(Dropout(0))

model.add(Dense(1))

model.add(Activation('linear'))
model.compile(loss='mse', optimizer='rmsprop',metrics=['acc'])

iters = 25
history_close = model.fit(x_train_close, y_train_close, batch_size=256, epochs=iters, verbose=1, validation_split=0.2)
history_open = model.fit(x_train_open, y_train_open, batch_size=256, epochs=iters, verbose=1, validation_split=0.2)
history_high = model.fit(x_train_high, y_train_high, batch_size=256, epochs=iters, verbose=1, validation_split=0.2)
history_low = model.fit(x_train_low, y_train_low, batch_size=256, epochs=iters, verbose=1, validation_split=0.2)

#@title Default title text
plt.plot(history_close.history['loss'])
plt.plot(history_close.history['val_loss'])
plt.plot(history_open.history['loss'])
plt.plot(history_open.history['val_loss'])
plt.plot(history_high.history['loss'])
plt.plot(history_high.history['val_loss'])
plt.plot(history_low.history['loss'])
plt.plot(history_low.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'validation'], loc='upper left')
plt.show()
# model.metrics_names
# plt.plot(history.history['acc'])
# plt.plot(history.history['val_acc'])
# plt.legend(['accuracy','validation accuracy'])



import plotly.graph_objects as go
train_predict_close = model.predict(x_train_close)
test_predict_close = model.predict(x_test_close)
train_predict_open = model.predict(x_train_open)
test_predict_open = model.predict(x_test_open)
train_predict_high = model.predict(x_train_high)
test_predict_high = model.predict(x_test_high)
train_predict_low = model.predict(x_train_low)
test_predict_low = model.predict(x_test_low)


train_predict_unnorm_close = scaler.inverse_transform(train_predict_close)
test_predict_unnorm_close = scaler.inverse_transform(test_predict_close)
train_predict_unnorm_open = scaler.inverse_transform(train_predict_open)
test_predict_unnorm_open = scaler.inverse_transform(test_predict_open)
train_predict_unnorm_high = scaler.inverse_transform(train_predict_high)
test_predict_unnorm_high = scaler.inverse_transform(test_predict_high)
train_predict_unnorm_low = scaler.inverse_transform(train_predict_low)
test_predict_unnorm_low = scaler.inverse_transform(test_predict_low)


trainPredictPlot_close = np.empty_like(price_close)
trainPredictPlot_open = np.empty_like(price_open)
trainPredictPlot_high = np.empty_like(price_high)
trainPredictPlot_low = np.empty_like(price_low)


trainPredictPlot_close[:,:] = np.nan
trainPredictPlot_open[:,:] = np.nan
trainPredictPlot_high[:,:] = np.nan
trainPredictPlot_low[:,:] = np.nan

trainPredictPlot_close[look_back:len(train_predict_unnorm_close)+look_back,:] = train_predict_unnorm_close
trainPredictPlot_open[look_back:len(train_predict_unnorm_open)+look_back,:] = train_predict_unnorm_open
trainPredictPlot_high[look_back:len(train_predict_unnorm_high)+look_back,:] = train_predict_unnorm_high
trainPredictPlot_low[look_back:len(train_predict_unnorm_low)+look_back,:] = train_predict_unnorm_low

testPredictPlot_close = np.empty_like(price_close)
testPredictPlot_open = np.empty_like(price_open)
testPredictPlot_high = np.empty_like(price_high)
testPredictPlot_low = np.empty_like(price_low)
testPredictPlot_close[:,:] = np.nan
testPredictPlot_open[:,:] = np.nan
testPredictPlot_high[:,:] = np.nan
testPredictPlot_low[:,:] = np.nan

testPredictPlot_close[len(train_predict_unnorm_close)+(look_back*2)+1:len(price_close)-1,:] = train_predict_unnorm_close
testPredictPlot_open[len(train_predict_unnorm_open)+(look_back*2)+1:len(price_open)-1,:] = train_predict_unnorm_open
testPredictPlot_high[len(train_predict_unnorm_high)+(look_back*2)+1:len(price_high)-1,:] = train_predict_unnorm_high
testPredictPlot_low[len(train_predict_unnorm_low)+(look_back*2)+1:len(price_low)-1,:] = train_predict_unnorm_low


plt.figure(figsize=(50,50))

plt.plot(price_close,'g',label ='original close data')
plt.plot(trainPredictPlot_close, 'r', label='training close set')
plt.plot(testPredictPlot_close, 'r', label = 'predicted close set')
plt.legend(loc ='upper left')
plt.xlabel('time in days')
plt.ylabel('price')
plt.grid()
plt.show


plt.plot(price_open,'g',label ='original open data')
plt.plot(trainPredictPlot_open, 'b', label='training open set')
plt.plot(testPredictPlot_open, 'b', label = 'predicted open set')
plt.legend(loc ='upper left')
plt.xlabel('time in days')
plt.ylabel('price')
plt.grid()
plt.show


plt.plot(price_high,'g',label ='original high data')
plt.plot(trainPredictPlot_high, 'g', label='training high set')
plt.plot(testPredictPlot_high, 'g', label = 'predicted high set')
plt.legend(loc ='upper left')
plt.xlabel('time in days')
plt.ylabel('price')
plt.grid()
plt.show


# plt.plot(price_low,'g',label ='original close data')
# plt.plot(trainPredictPlot_low, 'y', label='training low set')
# plt.plot(testPredictPlot_low, 'y', label = 'predicted low set')
# plt.legend(loc ='upper left')
# plt.xlabel('time in days')
# plt.ylabel('price')
# plt.grid()
# plt.show



# Create figure
# fig = go.Figure()

# fig.add_trace(
#     go.Candlestick(x=list(df.date),open=list(df.open), high=list(df.high), low=list(df.low), close=list(df.close)))

# # Set title
# fig.update_layout(
#     title_text="Time series with range slider and selectors"
# )

# Add range slider
# fig.update_layout(
#     xaxis=dict(
#         rangeselector=dict(
#             buttons=list([
#                 dict(count=1,
#                      label="1m",
#                      step="month",
#                      stepmode="backward"),
#                 dict(count=6,
#                      label="6m",
#                      step="month",
#                      stepmode="backward"),
#                 dict(count=1,
#                      label="YTD",
#                      step="year",
#                      stepmode="todate"),
#                 dict(count=1,
#                      label="1y",
#                      step="year",
#                      stepmode="backward"),
#                 dict(step="all")
#             ])
#         ),
#         rangeslider=dict(
#             visible=True
#         ),
#         type="date"
#     )
# )

# fig.show()

import plotly.graph_objects as go

# Create figure
fig = go.Figure()

fig.add_trace(
    go.Candlestick(x=list(df.date),open=list(df.open), high=list(df.high), low=list(df.low), close=list(df.close)))
# Add range slider
fig.update_layout(
    xaxis=dict(
        rangeselector=dict(
            buttons=list([
                dict(count=1,
                     label="1m",
                     step="month",
                     stepmode="backward"),
                dict(count=6,
                     label="6m",
                     step="month",
                     stepmode="backward"),
                dict(count=1,
                     label="YTD",
                     step="year",
                     stepmode="todate"),
                dict(count=1,
                     label="1y",
                     step="year",
                     stepmode="backward"),
                dict(step="all")
            ])
        ),
        rangeslider=dict(
            visible=True
        ),
        type="date"
    )
)
fig.update_yaxes(fixedrange=False)
fig.show()

